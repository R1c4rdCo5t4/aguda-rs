//Abstract syntax types generated by rustlr for grammar aguda
    
#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_imports)]
#![allow(dead_code)]
extern crate rustlr;
pub use rustlr::LC;
use rustlr::LBox;

#[derive(Debug)]
pub enum Else<'lt> {
  Else_35,
  ELSE_34(LBox<Expr<'lt>>),
  Else_Nothing,
}
impl<'lt> Default for Else<'lt> { fn default()->Self { Else::Else_Nothing } }

#[derive(Debug)]
pub enum Type {
  Type_11(BaseType),
  Type_Nothing,
}
impl Default for Type { fn default()->Self { Type::Type_Nothing } }

#[derive(Debug)]
pub enum ChainTail<'lt> {
  ChainTail_26,
  ChainTail_25(LBox<Expr<'lt>>,LBox<ChainTail<'lt>>),
  ChainTail_Nothing,
}
impl<'lt> Default for ChainTail<'lt> { fn default()->Self { ChainTail::ChainTail_Nothing } }

#[derive(Debug)]
pub enum BaseType {
  STRINGTYPE,
  UNITTYPE,
  BOOLTYPE,
  INTTYPE,
  BaseType_Nothing,
}
impl Default for BaseType { fn default()->Self { BaseType::BaseType_Nothing } }

#[derive(Debug)]
pub enum FunType {
  FunType_17(TypeList,Type),
  FunType_18(Type,Type),
  FunType_Nothing,
}
impl Default for FunType { fn default()->Self { FunType::FunType_Nothing } }

#[derive(Debug)]
pub enum Expr<'lt> {
  MulDiv_50(LBox<Expr<'lt>>,LBox<Expr<'lt>>),
  MulDiv_51(LBox<Expr<'lt>>,LBox<Expr<'lt>>),
  MulDiv_52(LBox<Expr<'lt>>,LBox<Expr<'lt>>),
  AddSub_47(LBox<Expr<'lt>>,LBox<Expr<'lt>>),
  AddSub_48(LBox<Expr<'lt>>,LBox<Expr<'lt>>),
  Unary_56(LBox<Expr<'lt>>),
  Unary_57(LBox<Expr<'lt>>),
  ID_63(&'lt str,LBox<Expr<'lt>>),
  ID_64(&'lt str,Vec<LC<Expr<'lt>>>),
  FALSE,
  UNIT,
  TRUE,
  STRING(&'lt str),
  NULL,
  NUM(i64),
  IF_32(LBox<Expr<'lt>>,LBox<Expr<'lt>>,LBox<Else<'lt>>),
  SET_28(LBox<Expr<'lt>>,LBox<Expr<'lt>>),
  WHILE_29(LBox<Expr<'lt>>,LBox<Expr<'lt>>),
  LET_27(&'lt str,Type,LBox<Expr<'lt>>),
  NEW_30(Type,LBox<Expr<'lt>>,LBox<Expr<'lt>>),
  Comp_44(LBox<Expr<'lt>>,LBox<Expr<'lt>>),
  Comp_41(LBox<Expr<'lt>>,LBox<Expr<'lt>>),
  Comp_40(LBox<Expr<'lt>>,LBox<Expr<'lt>>),
  Comp_43(LBox<Expr<'lt>>,LBox<Expr<'lt>>),
  Comp_45(LBox<Expr<'lt>>,LBox<Expr<'lt>>),
  Comp_42(LBox<Expr<'lt>>,LBox<Expr<'lt>>),
  Pow_54(LBox<Expr<'lt>>,LBox<Expr<'lt>>),
  Chain_24(LBox<Expr<'lt>>,LBox<ChainTail<'lt>>),
  And_38(LBox<Expr<'lt>>,LBox<Expr<'lt>>),
  Or_36(LBox<Expr<'lt>>,LBox<Expr<'lt>>),
  ExprList_74(LBox<Expr<'lt>>,Vec<LC<Expr<'lt>>>),
  Expr_Nothing,
}
impl<'lt> Default for Expr<'lt> { fn default()->Self { Expr::Expr_Nothing } }

#[derive(Debug)]
pub enum Decl<'lt> {
  LET_5(&'lt str,Type,Expr<'lt>),
  LET_6(&'lt str,ParamList<'lt>,FunType,Expr<'lt>),
  Decl_Nothing,
}
impl<'lt> Default for Decl<'lt> { fn default()->Self { Decl::Decl_Nothing } }

#[derive(Debug)]
pub enum ArrayType {
  ArrayType_Nothing,
}
impl Default for ArrayType { fn default()->Self { ArrayType::ArrayType_Nothing } }

#[derive(Default,Debug)]
pub struct TypeList(pub Type,pub Vec<LC<Type>>,);

#[derive(Default,Debug)]
pub struct Program<'lt>(pub Vec<LC<Decl<'lt>>>,);

#[derive(Default,Debug)]
pub struct ParamList<'lt>(pub &'lt str,pub Vec<LC<&'lt str>>,);

