use std::str::FromStr;
use crate::ast::*;
use crate::lexer::Token;

grammar;

extern {
    type Location = usize;
    type Error = String;

    // map lexer tokens
    enum Token {
        "id"     => Token::Id(<String>),
        "num"    => Token::Int(<i64>),
        "string" => Token::String(<String>),
        "true"   => Token::True,
        "false"  => Token::False,
        "null"   => Token::Null,
        "unit"   => Token::Unit,
        ";"      => Token::Semicolon,
        "+"      => Token::Plus,
        "-"      => Token::Minus,
        "*"      => Token::Multiply,
        "/"      => Token::Divide,
        "%"      => Token::Modulo,
        "^"      => Token::Power,
        "=="     => Token::Equal,
        "!="     => Token::NotEqual,
        "<"      => Token::Less,
        "<="     => Token::LessOrEqual,
        ">"      => Token::Greater,
        ">="     => Token::GreaterOrEqual,
        "!"      => Token::Not,
        "||"     => Token::Or,
        "&&"     => Token::And,
        "("      => Token::LeftParen,
        ")"      => Token::RightParen,
        "["      => Token::LeftBracket,
        "]"      => Token::RightBracket,
        ","      => Token::Comma,
        "set"    => Token::Set,
        "let"    => Token::Let,
        ":"      => Token::Colon,
        "="      => Token::Assign,
        "->"     => Token::Arrow,
        "if"     => Token::If,
        "then"   => Token::Then,
        "else"   => Token::Else,
        "while"  => Token::While,
        "do"     => Token::Do,
        "new"    => Token::New,
        "|"      => Token::Pipe,
        "Int"    => Token::IntType,
        "Bool"   => Token::BoolType,
        "String" => Token::StringType,
        "Unit"   => Token::UnitType,
    }
}

// top-level rule that parses an entire aguda program as a sequence of declarations
pub Program: Vec<Declaration> = {
    <decls:Decl*> => decls,
}

Decl: Declaration = {
    DeclVar, // let id : type = expr
    DeclFunc, // let id (id, ...) : (type, ...) -> type = expr
}

DeclVar: Declaration = {
    "let" <id:Id> ":" <t:Type> "=" <e:Expr> => Declaration::LetVar(id, t, e),
}

DeclFunc: Declaration = {
    "let" <id:Id>
        "(" <params:FunParamIds> ")"
        ":" <sig:FunSignature>
        "=" <body:Expr>
    => Declaration::LetFun(id, params, sig.0, sig.1, body),
}

FunSignature: (Vec<Type>, Type) = {
    "(" <params:FunParamTypes> ")" "->" <ret:Type> => (params, ret), // multi param
    <single:Type> "->" <ret:Type> => (vec![single], ret), // single param
}

// comma separated list with at least one element
#[inline]
List<T>: Vec<T> = {
    <head:T> <tail:(("," T))*> => {
        let mut v = vec![head];
        for (_, t) in tail {
            v.push(t);
        }
        v
    }
}

#[inline]
Id: String = {
    <id:"id"> => id.to_string(),
}

#[inline]
FunParamIds: Vec<String> = List<Id>;

#[inline]
FunParamTypes: Vec<Type> = List<Type>;

#[inline]
FunArgs: Vec<Expression> = List<Expr>;

#[inline]
Type: Type = {
    <base:BaseType> <dims:("[" "]")*> => {
        dims.into_iter().fold(base, |acc, _| Type::Array(Box::new(acc)))
    }
}

#[inline]
BaseType: Type = {
    "Int"    => Type::Int,
    "Bool"   => Type::Bool,
    "String" => Type::String,
    "Unit"   => Type::Unit,
}

Expr: Expression = {
    ChainExpr,
}

ChainExpr: Expression = {
    // right associative
    <lhs:IfExpr> ";" <rhs:ChainExpr> => Expression::Chain(Box::new(lhs), Box::new(rhs)),
    IfExpr,
}

IfExpr: Expression = {
    MatchedIf,
    UnmatchedIf,
}

MatchedIf: Expression = {
    "if" <cond:OrExpr> "then" <then:MatchedIf> "else" <els:MatchedIf> =>
         Expression::IfElse(Box::new(cond), Box::new(then), Box::new(els)),
    StmtExpr,
}

UnmatchedIf: Expression = {
    "if" <cond:OrExpr> "then" <e:StmtExpr> =>
         Expression::IfElse(Box::new(cond), Box::new(e), Box::new(Expression::Unit)),
    "if" <cond:OrExpr> "then" <then:MatchedIf> "else" <els:UnmatchedIf> =>
         Expression::IfElse(Box::new(cond), Box::new(then), Box::new(els)),
}

StmtExpr: Expression = {
    "let" <id:Id> ":" <t:Type> "=" <e:MatchedIf>  => Expression::Let(id, t, Box::new(e)),
    "set" <lhs:Lhs> "=" <rhs:MatchedIf> => Expression::Set(lhs, Box::new(rhs)),
    "while" <cond:Expr> "do" <body:MatchedIf> => Expression::While(Box::new(cond), Box::new(body)),
    "new" <ty:Type> "[" <size:MatchedIf> "|" <init:MatchedIf> "]" => Expression::NewArray(ty, Box::new(size), Box::new(init)),
    OrExpr,
}

OrExpr: Expression = {
    // left associative
    <lhs:OrExpr> "||" <rhs:AndExpr> => Expression::BinOp(Box::new(lhs), Op::Or, Box::new(rhs)),
    AndExpr,
}

AndExpr: Expression = {
    // left associative
    <lhs:AndExpr> "&&" <rhs:EqExpr> => Expression::BinOp(Box::new(lhs), Op::And, Box::new(rhs)),
    EqExpr,
}

EqExpr: Expression = {
    // left associative
    <lhs:EqExpr> "==" <rhs:RelExpr> => Expression::BinOp(Box::new(lhs), Op::Equal, Box::new(rhs)),
    <lhs:EqExpr> "!=" <rhs:RelExpr> => Expression::BinOp(Box::new(lhs), Op::NotEqual, Box::new(rhs)),
    RelExpr,
}

RelExpr: Expression = {
    // non associative
    <lhs:AddSubExpr> "<"  <rhs:AddSubExpr> => Expression::BinOp(Box::new(lhs), Op::Less, Box::new(rhs)),
    <lhs:AddSubExpr> "<=" <rhs:AddSubExpr> => Expression::BinOp(Box::new(lhs), Op::LessEqual, Box::new(rhs)),
    <lhs:AddSubExpr> ">"  <rhs:AddSubExpr> => Expression::BinOp(Box::new(lhs), Op::Greater, Box::new(rhs)),
    <lhs:AddSubExpr> ">=" <rhs:AddSubExpr> => Expression::BinOp(Box::new(lhs), Op::GreaterEqual, Box::new(rhs)),
    AddSubExpr,
}

AddSubExpr: Expression = {
    // left associative
    <lhs:AddSubExpr> "+" <rhs:MulDivExpr> => Expression::BinOp(Box::new(lhs), Op::Add, Box::new(rhs)),
    <lhs:AddSubExpr> "-" <rhs:MulDivExpr> => Expression::BinOp(Box::new(lhs), Op::Sub, Box::new(rhs)),
    MulDivExpr,
}

MulDivExpr: Expression = {
    // left associative
    <lhs:MulDivExpr> "*" <rhs:PowExpr> => Expression::BinOp(Box::new(lhs), Op::Mul, Box::new(rhs)),
    <lhs:MulDivExpr> "/" <rhs:PowExpr> => Expression::BinOp(Box::new(lhs), Op::Div, Box::new(rhs)),
    <lhs:MulDivExpr> "%" <rhs:PowExpr> => Expression::BinOp(Box::new(lhs), Op::Mod, Box::new(rhs)),
    PowExpr,
}

PowExpr: Expression = {
    // right associative
    <lhs:UnaryMinExpr> "^" <rhs:PowExpr> => Expression::BinOp(Box::new(lhs), Op::Pow, Box::new(rhs)),
    UnaryMinExpr,
}

UnaryMinExpr: Expression = {
    // highest precedence operators
    "-" <e:UnaryMinExpr> => Expression::BinOp(Box::new(Expression::Num(0)), Op::Sub, Box::new(e)),
    "!" <e:UnaryMinExpr> => Expression::Not(Box::new(e)),
    BaseExpr,
}

BaseExpr: Expression = {
    <id:Id> "(" <args:FunArgs> ")" => Expression::FunCall(id, args),
    <lhs:Lhs> "[" <idx:Expr> "]" => Expression::ArrayIndex(lhs, Box::new(idx)),
    <id:Id> => Expression::Id(id),
    "(" <e:Expr> ")" => e,
    LiteralExpr,
}

LiteralExpr: Expression = {
    <s:"string"> => Expression::Str(s.to_string()),
    <n:"num">    => Expression::Num(n.to_string().parse().unwrap()),
    "true"       => Expression::Bool(true),
    "false"      => Expression::Bool(false),
    "null"       => Expression::Null,
    "unit"       => Expression::Unit,
}

Lhs: Lhs = {
    <id:Id> => Lhs::Var(id), // variable
    <lhs:Lhs> "[" <idx:Expr> "]" => Lhs::Index(Box::new(lhs), Box::new(idx)), // array index
}
