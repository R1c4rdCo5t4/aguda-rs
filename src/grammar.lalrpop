use std::str::FromStr;
use crate::ast::*;
use crate::lexer::Token;

grammar;

// map string representations to lexer tokens
extern {
    type Location = usize;
    type Error = String;

    enum Token {
        "id"     => Token::Id(<String>),
        "num"    => Token::Int(<i64>),
        "string" => Token::String(<String>),
        "true"   => Token::True,
        "false"  => Token::False,
        "null"   => Token::Null,
        "unit"   => Token::Unit,
        ";"      => Token::Semicolon,
        "+"      => Token::Plus,
        "-"      => Token::Minus,
        "*"      => Token::Multiply,
        "/"      => Token::Divide,
        "%"      => Token::Modulo,
        "^"      => Token::Power,
        "=="     => Token::Equal,
        "!="     => Token::NotEqual,
        "<"      => Token::Less,
        "<="     => Token::LessOrEqual,
        ">"      => Token::Greater,
        ">="     => Token::GreaterOrEqual,
        "!"      => Token::Not,
        "||"     => Token::Or,
        "&&"     => Token::And,
        "("      => Token::LeftParen,
        ")"      => Token::RightParen,
        "["      => Token::LeftBracket,
        "]"      => Token::RightBracket,
        ","      => Token::Comma,
        "set"    => Token::Set,
        "let"    => Token::Let,
        ":"      => Token::Colon,
        "="      => Token::Assign,
        "->"     => Token::Arrow,
        "if"     => Token::If,
        "then"   => Token::Then,
        "else"   => Token::Else,
        "while"  => Token::While,
        "do"     => Token::Do,
        "new"    => Token::New,
        "|"      => Token::Pipe,
        "Int"    => Token::IntType,
        "Bool"   => Token::BoolType,
        "String" => Token::StringType,
        "Unit"   => Token::UnitType,
    }
}

// top-level rule that parses an entire aguda program as a sequence of declarations
pub Program: Vec<Declaration> = {
    <decls:Decl*> => decls,
}

Decl: Declaration = {
    <d:DeclVar> => d, // let id ":" type "=" expr
    <d:DeclFunc> => d, // let id (id, ...) : (type, ...) -> type = expr
}

DeclVar: Declaration = {
    "let" <id:Id> ":" <t:Type> "=" <e:Expr> => Declaration::LetVar(id, t, e), // let id : type = expr
}

DeclFunc: Declaration = {
    "let" <id:Id>
        "(" <params:FunParamIds> ")"
        ":" <sig:FunSignature>
        "=" <body:Expr>
    => Declaration::LetFun(id, params, sig.0, sig.1, body), // let id(args+) : (type+) -> type = expr
};

FunSignature: (Vec<Type>, Type) = {
    "(" <params:FunParamTypes> ")" "->" <ret:Type> => (params, ret), // multi param
    <single:Type> "->" <ret:Type> => (vec![single], ret), // single param
};

// comma separated list with at least one element
List<T>: Vec<T> = {
    <head:T> <tail:(("," T))*> => {
        let mut v = vec![head];
        for (_, t) in tail {
            v.push(t);
        }
        v
    }
};

Id: String = {
    <id:"id"> => id.to_string(),
}

FunParamIds: Vec<String> = List<Id>;

FunParamTypes: Vec<Type> = List<Type>;

FunArgs: Vec<Expression> = List<Expr>;

#[inline]
Type: Type = {
    <base:BaseType> <dims:("[" "]")*> => {
        dims.into_iter().fold(base, |acc, _| Type::Array(Box::new(acc)))
    }
}

BaseType: Type = {
    "Int"    => Type::Int,
    "Bool"   => Type::Bool,
    "String" => Type::String,
    "Unit"   => Type::Unit,
}

Expr: Expression = {
    <e:ChainExpr> => e,
}

ChainExpr: Expression = {
    // right associative
    <lhs:IfExpr> ";" <rhs:ChainExpr> => Expression::Chain(Box::new(lhs), Box::new(rhs)),
    <e:IfExpr> => e,
}

// distinguishes matched and unmatched ifs
IfExpr: Expression = {
    <m:MatchedIf> => m,
    <u:UnmatchedIf> => u,
}

// both then and else parts with nesting
MatchedIf: Expression = {
    "if" <cond:OrExpr> "then" <then:MatchedIf> "else" <els:MatchedIf> =>
         Expression::IfElse(Box::new(cond), Box::new(then), Box::new(els)),
    <e:StmtExpr> => e,
}

// the if without else or with unmatched else
UnmatchedIf: Expression = {
    "if" <cond:OrExpr> "then" <e:StmtExpr> =>
         Expression::IfElse(Box::new(cond), Box::new(e), Box::new(Expression::Unit)),
    "if" <cond:OrExpr> "then" <then:MatchedIf> "else" <els:UnmatchedIf> =>
         Expression::IfElse(Box::new(cond), Box::new(then), Box::new(els)),
}

// the main statement expression
StmtExpr: Expression = {
    "let" <id:Id> ":" <t:Type> "=" <e:StmtExpr>  => Expression::Let(id, t, Box::new(e)),
    "set" <lhs:Lhs> "=" <rhs:StmtExpr> => Expression::Set(lhs, Box::new(rhs)),
    "while" <cond:Expr> "do" <body:StmtExpr> => Expression::While(Box::new(cond), Box::new(body)),
    "new" <ty:Type> "[" <size:StmtExpr> "|" <init:StmtExpr> "]" => Expression::NewArray(ty, Box::new(size), Box::new(init)),
    <e:OrExpr> => e,
}

OrExpr: Expression = {
    // left associative
    <lhs:OrExpr> "||" <rhs:AndExpr> => Expression::BinOp(Box::new(lhs), Op::Or, Box::new(rhs)),
    <e:AndExpr> => e,
}

AndExpr: Expression = {
    // left associative
    <lhs:AndExpr> "&&" <rhs:EqExpr> => Expression::BinOp(Box::new(lhs), Op::And, Box::new(rhs)),
    <e:EqExpr> => e,
}

EqExpr: Expression = {
    // left associative
    <lhs:EqExpr> "==" <rhs:RelExpr> => Expression::BinOp(Box::new(lhs), Op::Equal, Box::new(rhs)),
    <lhs:EqExpr> "!=" <rhs:RelExpr> => Expression::BinOp(Box::new(lhs), Op::NotEqual, Box::new(rhs)),
    <e:RelExpr> => e,
}

RelExpr: Expression = {
    // non associative
    <lhs:AddSubExpr> "<"  <rhs:AddSubExpr> => Expression::BinOp(Box::new(lhs), Op::Less, Box::new(rhs)),
    <lhs:AddSubExpr> "<=" <rhs:AddSubExpr> => Expression::BinOp(Box::new(lhs), Op::LessEqual, Box::new(rhs)),
    <lhs:AddSubExpr> ">"  <rhs:AddSubExpr> => Expression::BinOp(Box::new(lhs), Op::Greater, Box::new(rhs)),
    <lhs:AddSubExpr> ">=" <rhs:AddSubExpr> => Expression::BinOp(Box::new(lhs), Op::GreaterEqual, Box::new(rhs)),
    <e:AddSubExpr> => e,
}

AddSubExpr: Expression = {
    // left associative
    <lhs:AddSubExpr> "+" <rhs:MulDivExpr> => Expression::BinOp(Box::new(lhs), Op::Add, Box::new(rhs)),
    <lhs:AddSubExpr> "-" <rhs:MulDivExpr> => Expression::BinOp(Box::new(lhs), Op::Sub, Box::new(rhs)),
    <e:MulDivExpr> => e,
}

MulDivExpr: Expression = {
    // left associative
    <lhs:MulDivExpr> "*" <rhs:PowExpr> => Expression::BinOp(Box::new(lhs), Op::Mul, Box::new(rhs)),
    <lhs:MulDivExpr> "/" <rhs:PowExpr> => Expression::BinOp(Box::new(lhs), Op::Div, Box::new(rhs)),
    <lhs:MulDivExpr> "%" <rhs:PowExpr> => Expression::BinOp(Box::new(lhs), Op::Mod, Box::new(rhs)),
    <e:PowExpr> => e,
}

PowExpr: Expression = {
    // right associative
    <lhs:UnaryExpr> "^" <rhs:PowExpr> => Expression::BinOp(Box::new(lhs), Op::Pow, Box::new(rhs)),
    <e:UnaryExpr> => e,
};

UnaryExpr: Expression = {
    // highest precedence operators
    "-" <e:UnaryExpr> => Expression::BinOp(Box::new(Expression::Num(0)), Op::Sub, Box::new(e)),
    "!" <e:UnaryExpr> => Expression::Not(Box::new(e)),
    <e:LiteralExpr> => e,
};

// literals and parenthesis
LiteralExpr: Expression = {
    <n:"num">        => Expression::Num(n as i64),
    <s:"string">     => Expression::Str(s.to_string()),
    "true"           => Expression::Bool(true),
    "false"          => Expression::Bool(false),
    "null"           => Expression::Null,
    "unit"           => Expression::Unit,
    "(" <e:Expr> ")" => e,
    <e:IdExpr>       => e,
};

// id, function call and array indexing
IdExpr: Expression = {
    <id:Id>                        => Expression::Id(id),
    <id:Id> "(" <args:FunArgs> ")" => Expression::FunCall(id, args),
    <lhs:Lhs> "[" <idx:Expr> "]" => Expression::ArrayIndex(lhs, Box::new(idx)),
}

// left-hand side of an assignment
Lhs: Lhs = {
    <id:Id> => Lhs::Var(id), // variable
    <lhs:Lhs> "[" <idx:Expr> "]" => Lhs::Index(Box::new(lhs), Box::new(idx)), // array index
};
