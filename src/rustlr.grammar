auto # automatic lexer and ast generation

lifetime 'lt # to indicate that tokens' string slices are borrowed from the input source with the same lifetime

terminals ; , -> + - * / ^ == != < <= > >= && ! [ ] ( )

# reserved operators
lexterminal COLON :
lexterminal MOD %
lexterminal PIPE |
lexterminal ASSIGN =
lexterminal OR ||

# because we want to use a custom regex for identifier and rule priority and regex lookaheads are not supported, we need to use custom regex matching for each alphanumeric token (rustlr limitation)

lexattribute add_custom("WHILE",   r"\bwhile\b")
lexattribute add_custom("LET",     r"\blet\b")
lexattribute add_custom("SET",     r"\bset\b")
lexattribute add_custom("IF",      r"\bif\b")
lexattribute add_custom("THEN",    r"\bthen\b")
lexattribute add_custom("ELSE",    r"\belse\b")
lexattribute add_custom("DO",      r"\bdo\b")
lexattribute add_custom("NEW",     r"\bnew\b")
lexattribute add_custom("TRUE",    r"\btrue\b")
lexattribute add_custom("FALSE",   r"\bfalse\b")
lexattribute add_custom("NULL",    r"\bnull\b")
lexattribute add_custom("UNIT",    r"\bunit\b")
lexattribute add_custom("TINT",    r"\bInt\b")
lexattribute add_custom("TBOOL",   r"\bBool\b")
lexattribute add_custom("TSTRING", r"\bString\b")
lexattribute add_custom("TUNIT",   r"\bUnit\b")

valueterminal WHILE   ~ &'lt str ~ Custom("WHILE", WHILE)     ~ WHILE
valueterminal LET     ~ &'lt str ~ Custom("LET", LET)         ~ LET
valueterminal SET     ~ &'lt str ~ Custom("SET", SET)         ~ SET
valueterminal IF      ~ &'lt str ~ Custom("IF", IF)           ~ IF
valueterminal THEN    ~ &'lt str ~ Custom("THEN", THEN)       ~ THEN
valueterminal ELSE    ~ &'lt str ~ Custom("ELSE", ELSE)       ~ ELSE
valueterminal DO      ~ &'lt str ~ Custom("DO", DO)           ~ DO
valueterminal NEW     ~ &'lt str ~ Custom("NEW", NEW)         ~ NEW
valueterminal TRUE    ~ &'lt str ~ Custom("TRUE", TRUE)       ~ TRUE
valueterminal FALSE   ~ &'lt str ~ Custom("FALSE", FALSE)     ~ FALSE
valueterminal NULL    ~ &'lt str ~ Custom("NULL", NULL)       ~ NULL
valueterminal UNIT    ~ &'lt str ~ Custom("UNIT", UNIT)       ~ UNIT
valueterminal TINT    ~ &'lt str ~ Custom("TINT", TINT)       ~ TINT
valueterminal TBOOL   ~ &'lt str ~ Custom("TBOOL", TBOOL)     ~ TBOOL
valueterminal TSTRING ~ &'lt str ~ Custom("TSTRING", TSTRING) ~ TSTRING
valueterminal TUNIT   ~ &'lt str ~ Custom("TUNIT", TUNIT)     ~ TUNIT

lexattribute add_custom("Id", r"[a-zA-Z_][a-zA-Z0-9'_]*")

valueterminal Id ~ &'lt str ~ Custom("Id", id) ~ id
valueterminal Num ~ i64 ~ Num(n) ~ n
valterminal Str string literal

# comments
lexattribute set_line_comment("--")

# nonterminals
nonterminals Program Decl Type Expr ParamList TypeList ExprList FunType Else Lhs
nonterminal SingleParam : FunType
nonterminal MultiParam : FunType
nonterminal ArrayType : Type
nonterminal BaseType : Type
nonterminal Chain : Expr
nonterminal Stmt : Expr
nonterminal Op : Expr
nonterminal Primary : Expr
nonterminal Literal : Expr

# precedence and associativity of operators
right ; 1
right -> 1
nonassoc ELSE 2
nonassoc IF 3
nonassoc WHILE 3
left OR 4
left && 5
left == 6
left != 6
left < 7
left <= 7
left > 7
left >= 7
left + 8
left - 8
left * 9
left / 9
left MOD 9
right ^ 10
right ! 11
right - 11

startsymbol Program

Program --> Decl*
Decl:Var --> LET Id:id COLON Type:ty ASSIGN Expr:expr
Decl:Fun --> LET Id:id ( ParamList:params ) COLON FunType:ty ASSIGN Expr:expr
ParamList --> Id (, Id)*

Type --> BaseType | ArrayType
BaseType:Int --> TINT
BaseType:Bool --> TBOOL
BaseType:Unit --> TUNIT
BaseType:String --> TSTRING
ArrayType:Array --> Type [ ]

FunType --> SingleParam | MultiParam
SingleParam:SingleParam --> Type:ty -> Type:ret
MultiParam:MultiParam --> ( TypeList:ty ) -> Type:ret
TypeList:TypeList --> Type (, Type)*

Expr --> Chain
Chain:Chain --> Stmt (; Chain)*
Stmt:Let --> LET Id:id COLON Type:ty ASSIGN Stmt:expr
Stmt:Set --> SET Lhs:lhs ASSIGN Stmt:expr
Stmt:While --> WHILE Stmt:cond DO Stmt:expr
Stmt:New --> NEW Type:ty [ Expr:size PIPE Expr:init ]
Stmt:If --> IF Stmt:cond THEN Stmt:then Else:els
Else:Else --> ELSE Stmt
Else:Unit --> # Îµ
Stmt --> Op

Op:Or --> Op OR Op
Op:And --> Op && Op
Op:Eq --> Op == Op
Op:Neq --> Op != Op
Op:Lt --> Op < Op
Op:Leq --> Op <= Op
Op:Gt --> Op > Op
Op:Geq --> Op >= Op
Op:Add --> Op + Op
Op:Sub --> Op - Op
Op:Mul --> Op * Op
Op:Div --> Op / Op
Op:Mod --> Op MOD Op
Op:Pow --> Op ^ Op
Op:Not --> ! Op
Op:Neg --> - Op
Op --> Primary

Primary:FunCall --> Id ( ExprList )
Primary:Index --> Lhs [ Expr ]
Primary:Id --> Id
Primary:Paren --> ( Expr )
Primary --> Literal

Lhs:Id --> Id
Lhs:Index --> Lhs [ Expr ]
ExprList --> Expr (, Expr)*

Literal:Num --> Num
Literal:String --> Str
Literal:True --> TRUE
Literal:False --> FALSE
Literal:Null --> NULL
Literal:Unit --> UNIT
